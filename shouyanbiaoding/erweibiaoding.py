import numpy as np
import cv2 as cv
from scipy import linalg
import numpy as np
#把旋转向量换成旋转矩阵
R_vec = np.array([[-0.37187917],  [-0.37772276],  [-1.51350696]])
R_mat = cv.Rodrigues(R_vec)[0]
#像素坐标系
ZC=422.29379476
xiangsu=np.array([ZC*275.07486, ZC*345.282,ZC,0 ])
#空间坐标系：
kongjian=np.array([0,0,0,1])
#相机内参
neican=np.array( [[630.4694543,0,323.11443578,0],[0,632.99644138, 292.90037764,0] ,[  0,0,1,0],[0,0,0,0]])
#相机外参数
R=np.array([[ 0.02270092,  0.99969845, -0.00936348],[-0.88686888,  0.02446018,  0.46137327],[ 0.46146318, -0.00216942,  0.88715671]])
qici=np.array([0,0,0,1])
T=np.array([-32.33337524,35.26258248,422.29379476])
RT=np.insert(R,3,T,axis=1)
RT2=np.insert(RT,3,qici,axis=0)
#print(RT2)
product1 = neican @ RT2
product=product1 @kongjian
print(product1)
#像素坐标系求空间坐标系
x = linalg.solve(product1, xiangsu)
print(x)
u=267.0
v=264.0
#这个公式是通过Matlab 符号计算得出。
x=(50*(396847816569148721097141649408000*u - 16085782132432423319355972278602947*v + 5452351435172054767759366385827840000))/(878249620427882592959851464228864*v - 17838184803991743146338392473600*u + 818317439724606094205989412590216875)
y=(625*(4783412137738645094003834864185125*u + 300411279361398248838606383742976*v - 1417820931828012533005683415627984000))/(4*(878249620427882592959851464228864*v - 17838184803991743146338392473600*u + 818317439724606094205989412590216875))
#转成空间坐标系2
x2=-x+24*6
print(x,y,x2)
#空间坐标系2转成末端坐标系
x3=x2*np.cos(120*np.pi/180)+y*np.sin(120*np.pi/180)
y3=-x2*np.sin(120*np.pi/180)+y*np.cos(120*np.pi/180)
print(x3,y3)
